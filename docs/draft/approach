\section{Approaches}
\subsection{Framework}

\subsection{Path searching layer}
All paths searching algorihtms here are centric algorithms i.e. run at every node in exact oder thus, every node has the same results. The algorithms need some information in advance such as size, topology, torus of the partition, coordinates of all nodes in the partition. The informaition is collected once at the begining. The algorithms, also need to have the pair of source-destination and sometimes the data size to find paths between them.

\subsubsection{Heuristic 1}
In this approach, we search for paths between each pair of source and destination. We explore from all the destination in all possible directions. Whenever we reach a destination, we mark the destination as found to no longer search for it on other explorering paths. In this algorithm, we do not limit exploring paths by any constraints.

\begin{algorithm}
\textbf{Input:} Set of pairs of source-destination (\textit{s$_i$, d$_i$}). Number of nodes \textit{n}. Graph of nodes. \\
\textbf{Output:} Set of paths: one path for a pair of source-destination \\
\\
Init:
    \begin{algorithmic}
	\State queue$<$struct path$>$ \textit{exploring\_paths};
	\State queue$<$struct path$>$ \textit{complete\_paths};
	\State bool \textit{visisted}[\textit{n}][\textit{n}];
	\For {0 $<=$ {\it i}, \textit{j} $<$ \textit{n}} 
	    \State \textit{visited}[{\it i}][{\it j}] = false;
	\EndFor
    \end{algorithmic}
Main:

\begin{algorithmic}
    \Function {Heuristic\_search\_I}{}

    \For {each source \textit{s$_i$}}
	\State check\_and\_add\_new\_path({\it s}$_i$, {\it s}$_i$, null)
    \EndFor

    \While {(\textit{exploring\_path} != empty)}
	\State path \textit{p} = \textit{exploring\_paths}.pop()
	\State get the furthest point {\it u} of {\it p}
	\State check\_and\_add\_new\_path({\it s}$_i$, \textit{u}, {\it p})
    \EndWhile

    \EndFunction
\\
    \Function{check\_and\_add\_new\_path}{int \textit{s$_i$}, int \textit{u}, path {\it op}}
	\For {each neighbor {\it v} of \textit{u}}
	    \If {(!{\it visited}[{\it s$_i$}][{\it v}])}
		\State create an arc \textit{a}$<$\textit{u}, \textit{v}$>$
                \State create a path \textit{np} = {\it op}
	        \State enqueue arc \textit{a} to \textit{np}
	        \State enqueue \textit{np} to \textit{exploring\_paths}
		\If {{\it v} is one of the destinations of \textit{s$_i$}}
		    \State enqueue \textit{np} to \textit{complete\_paths}
                \EndIf
	        \State {\it visited}[\textit{s$_i$}][\textit{v}] = true;
	    \EndIf
	\EndFor
    \EndFunction
\end{algorithmic}

\caption{Heuristic Alg I: Exploring all paths}
\label{alg:h1}

\end{algorithm}

In the \textbf{Algorithm \ref{alg:h1}}, we start by adding \\

Time complexity: The graph has V vertices and E edges. We have M sources and N destination making K pairs of (source, destinatinon), then the time complexity of the \textbf{Algorithm \ref{alg:h1}} is XXXX.

\subsubsection{Heuristic 2}
This algorithm is an extension from Heuristic 1, while we limit the exploring paths by both the number of hops and minimizing the maximum load. We do so by maintaining a min heap of paths. The comparison function of the heap is based on both the number of hops and maximum load on each path.

\begin{algorithm}

\caption{Heuristic Alg II: Constraints by number of hops and max load}
\label{alg:h2}
\end{algorithm}

\subsubsection{Heuristic 3}

\begin{algorithm}
\textbf{Input:} Set of pairs of source-destination (\textit{s$_i$, d$_i$}). Number of nodes \textit{n}. Graph of nodes. Number of shortest path \textit{k}\\
\textbf{Output:} Set of paths: \textit{k} paths for a pair of source-destination\\
Init:
    \begin{algorithmic}
        \State queue$<$struct path$>$ \textit{complete\_paths};
    \end{algorithmic}
Main:
\begin{algorithmic}
    \Function {Heuristic\_search\_II}{}
	\For {each pair of source-dest (\textit{s$_i$}, \textit{s$_i$})}
	    \State Use Yen's algorithm to search for \textit{k} shortest paths
	    \State Add \textit{k} shortest paths into \textit{complete\_paths}
	\EndFor
    \EndFunction
\end{algorithmic}

\caption{Heuristic Alg II: k shortest paths}
\label{alg:h3}

\end{algorithm}

In the \textbf{Algorithm \ref{alg:h3}}, we use Yen's algorithm to search for k shortest paths between \textit{s$_i$, d$_i$}.

\subsection{Schedule layer}
Order of messages into sending queue: 3 types of messages: local messages (needed to send), fowarding messages (needed to send), its receiving messages. first come first serve, local messages first. forwa

When there are multiple ranks per node, which one will be choosen to receive data at the next dest (forwarding). Single rank to do or many rank to do, currently every rank executes data transfer.

\subsection{Transport layer}

\subsection{Supported components}

Topology reading, coord, neighbors, torus, size, routing order, graph generated.

Also set of benchmarks, tests.
