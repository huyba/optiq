\section{Multi-path Data Movement/Routing}
\label{sec:approach}

%TODO %Some introduction to this section may be required.

In Blue Gene/Q, data is routed through its interconnect using the default routing algorithms. The default routing algorithms perform well for many communication patterns \cite{Chen:BGQ}. However, for certain communication patterns (shown later in this paper), they result in poor performance due to unbalanced load on the physical network links resulting in significantly larger amounts of data being transferred over few links. This is because the default algorithms use a single path to transfer data between any two nodes in the system. In addition, data traverses along fixed paths on certain links regardless of the overall load of the system. Thus, some links are overloaded while other links have less data or may even be idle. This overloading is a bottleneck to the data movement throughput. Balancing the load on the physical links can remove the bottleneck and thus improve the data transfer throughput. In order to balance the load, we need to use idle or lightly-loaded links for data transfer. For this, we need to search for multiple paths between source and destination nodes and assign appropriate load on each path.

The above problem can be formulated as a multicommodity integral flow problem, which is shown to be NP-complete \cite{even1975}. Given a set of source and destination nodes, and the amount of data to be transferred from the sources to destinations, the problem is to find a set of paths from the source nodes to the destination nodes that results in high throughput. Additionally, the objective is to balance the overall system load in order to avoid congestion in the interconnect and to avoid overloading physical network links. In this paper, we propose two approaches to solve this problem.
%PM-BEGIN
%here, first describe briefly the approaches (which you have below), then talk about path search.
%PM-END

Present-day supercomputers have thousands of nodes and hundreds of thousands of edges due to complex interconnect topology. This implies a huge search space, thus leads to significant amount of time spending on searching for paths, calculating and balancing load in involving links. We reduce the search time while maintaining good quality of chosen paths by doing the follows:

\begin{itemize}
\item We simplify the load on a link by substituting the actual load i.e. the amount of data passing through the link by path load i.e. number paths that share the link. This is acceptable when the data amounts assigned on paths are similar.
\item We prune the search space by:
\begin{itemize}
\item Applying load path constraint and number of hops constraint while searching for paths.
\item Performing 2-step search. In the first step, we search for a number of shortest paths without any constraints. From the set of shortest paths, we apply constraints or use optimization methods to search for final set of paths in the second step.
\end{itemize}
\end{itemize}

In this paper, we propose two approaches aiming for balancing load on physical links: one heuristic algorithms and one model-based optimization approach. In both approaches, we use Yen's algorithm \cite{Yen:Kpath} to search for a set of shortest paths. After that, in the first approach, we use maximum load path constraint to prune the search space, while in the second approach, we use an optimization model with solvers to search for final paths. In this paper, we use Yen's algorithm, but any algorithms searches for K shortest paths should work as well.

In order to search for paths, we model the interconnect network as a graph. Each compute node is modeled as a vertex and each physical link is modeled as an edge. The bandwidth of a physical link is modeled as its corresponding edge's capacity. The need of data movement from source nodes to destination nodes is modeled as data movement from source vertices to destination vertices. The problem now becomes searching for paths to move data from source vertices to destination vertices to minimize tranfer time. The next subsection, we briefly describe the K shortest paths generation based on Yen's algorithm.

\subsection {K Shortest Path Generation}

\begin{algorithm}[!htbp]
\textbf{Input:} Set of pairs of source-destination (\textit{s$_i$, d$_i$}). Graph of nodes. Number of shortest path \textit{k}\\
\textbf{Output:} Set of paths: \textit{k} paths for a pair of source-destination\\
\begin{algorithmic}
\For {each pair of source-dest (\textit{s$_i$}, \textit{s$_i$})}
    \While{(less than k paths discovered $||$ still have paths to discover)}
	\State Use Yen's algorithm to search for the shortest path \textit{p}.
        \State Add \textit{p} into \textit{k\_paths} for later use.
    \EndWhile
\EndFor
\end{algorithmic}

\caption{K shortest paths generation}
\label{alg:h1}

\end{algorithm}

In this algorithm, we go throught all pairs of sources and destinations and generate k shortest paths for each pair. We do stop when either there is no more path to generate or we have enough k paths.

\subsection{Heuristic Approach}

In the Heurisic Approache, we use the k shortest paths for each pair of source and destination as a input. 

\begin{algorithm}[!htbp]
\textbf{Input:} Set of pairs of source-destination (\textit{s$_i$, d$_i$}) and their \textit{k\_paths}. \textit{maxload}\\
\textbf{Output:} Set of paths: \textit{selected\_paths} for data movement\\
Init:
    \begin{algorithmic}
        \State queue$<$struct path$>$ \textit{complete\_paths};\\
	int[][] loads: loads of all physical links, init to 0s.\\
    \end{algorithmic}
Main:
\begin{algorithmic}
    \Function {Heuristic\_search}{}
	\For {each pair of source-dest (\textit{s$_i$}, \textit{s$_i$})}
	    \State Get the first path \textit{p} out of set \textit{k\_paths}.
	    \State Check if adding \textit{p} make the current load over \textit{maxload}.
	    \State If Not, add \textit{p} into \textit{complete\_paths}
	    \State If Yes, check if there is at the current pair has at least one path.
	    \State If Not, increase the \textit{maxload} by 1
	\EndFor
    \EndFunction
\end{algorithmic}

\caption{Heuristic Alg: k shortest paths}
\label{alg:h2}

\end{algorithm}

In the \textbf{Algorithm \ref{alg:h3}}, we use Yen's algorithm to search for k shortest paths between \textit{s$_i$, d$_i$}.

In Agorithm 1 and 2, we aim on balancing the number of paths using physical link. However, we do not consider the actual amount of data transferred on each path. If multiple paths are found, the data is equally split among the paths. To gain better performance, we determine the amount of data to be transferred on each path by using a mathematical model to search for the amount of data to be transferred on each path. The approach takes a number of given paths and amount of data between 2 vertices and use solvers to search for the amount of data on each path. The detail is described as follows.

\subsection{Model Optimization Approach}

How do we come up with the model?

Here is the model with its description below.

\begingroup
\fontsize{9pt}{9pt}\selectfont

\begin{verbatim}

set Nodes;
set Arcs within Nodes cross Nodes;

set Jobs;
set Paths{Jobs};
set Path_Arcs{job in Jobs, p in Paths[job]} 
    within Arcs;

param Capacity{Arcs} >= 0 default Infinity;
param Demand {Jobs} default 0;

var Flow {job in Jobs, Paths[job]} >= 0;
var Z >= 0;

maximize obj: Z;

subject to

demand {job in Jobs}: sum {p in Paths[job]} 
	Flow[job,p] = Demand[job]*Z;

capacity {(i,j) in Arcs}:
  sum {job in Jobs, p in Paths[job]: 
    (i,j) in = Path_Arcs[job,p]} Flow[job,p] 
		<= Capacity[i,j];

\end{verbatim}

\endgroup

Model explanation:
\begin{itemize}
\item sets: we have 5 sets: \textit{Nodes}, \textit{Arcs}, \textit{OD}, \textit{Paths} and \textit{Path\_Arcs}. \textit{JobID}: is the set of transfers from sources to destinations. Each job is represented by a tuple (id, source, destination, demand (total data size to transfer)).
\item params: {\it Capacity}: capacity of each arc; {\it Demand}: amount of data to be transferred in each job between a pair of orgin and destination.
\item vars: \textit{Flow}: total flow of each job on each arc; \textit{Z}: is reversed of total time; \textit{total\_flow} total flow of all jobs going through an arc.
\item objective function: we want to minimize the time or maximize its reversed value i.e. maximize \textit{Z}.
\item constraints(subject to): \textit{zero\_flow}: total flow through a source is total going out of that source, total flow going through a destination is total flow going in that destination, for other nodes that total is 0; \textit{capacity}: total flow on an arc is less than its capacity.
\end{itemize}

We feed the model to solvers and get the paths with given proportional bandwidth. Based on that, we can decide how much data we can transfer alogn each path.

\begin{comment}
So far, we have presented different algorithms/approaches. Each has its own use case scenario. The Table \ref{tbl:approaches} describes the situation when to use each of them. 

\begin{table}[h]

\begin{center}
    \begin{tabular}{ | p{0.8cm} | p{2cm} | p{2cm} | p{2cm} |}
    \hline
     & BFS-based &  \multicolumn{2}{ c| }{Path-based} \\ \hline
     & Heuristics 1 & Heuristics 2 & Optimization Model \\ \hline
    Time Complexity & $O$(K * ($|$V$|$ + $|$E$|$)) & $O$(K * (Time complexity of the algrithms used to get k shortest paths)) & $O$(K * (Time complexity of the algrithms used to get k shortest paths) + Solving time) \\ \hline
    When to use & Very dense communication & Sparse comminication &  Medium dense where proportional throughtput can be gained \\
    \hline
    \end{tabular}

    \caption{Approaches: time complexity and usage}
    \label{tbl:approaches}

\end{center}
\end{table}

\end{comment}

We realize algoirthms and other work in a framework named OPTIQ.
