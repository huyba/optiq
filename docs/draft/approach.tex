\subsection{Heuristic Approach}
\label{sec:heuristic}

In this section, we describe our heuristic to select paths for each source-destination pair, given the set of $k$ shortest paths $k\_paths$. In this approach, we assume that same amount of data is transmitted over each path. Thus, the total load on a link can be represented by the number of paths using the link. In order to avoid overloading of the physical links and to achieve high performance, we select paths in such a way that satisfies the following two conditions:
\begin{enumerate}
\item Select as many paths as possible for any pair of source/destination. 
\item The maximum number of paths on any physical link is less than a given $maxload$ value.
\end{enumerate}
The above conditions ensure that we have multiple paths for each pair, and the load is balanced and it is within the upper limit of maximum load on the physical links. The brute force algorithm is to explore all combinations of paths for all source-destination pairs and examine the above two conditions in order to find the best set of paths. However, its time complexity is exponential. We propose a heuristic that outputs a set of paths without exhaustively searching the entire search space. Our heuristic iterates through all pairs of source/destination nodes to search for more paths until the $maxload$ value is reached. The pseudocode of our approach is presented in Algorithm~\ref{alg:heu}. 
\begin{algorithm}[!htbp]
\KwIn{Set of source-destination pairs $\mathcal{P}$ = \{(S, D) $|$ S, D $\in~N$\} and their $k$ shortest paths {$k\_paths$}. Maximum allowed load on a link $maxload$. $N\times N$ physical link load matrix $Load$.}
\KwOut{Set of selected paths for data movement: $paths$.}
%\begin{algorithmic}
%\Function {find\_paths}{}
	\While {($\mathcal{P}$ != $\phi$)} 
	{
		Select (s,d) from $\mathcal{P}$\; 
		Let i be the index of (s,d) \;
		$p~\leftarrow$ Select a path from $k\_paths_i$ \;
		$k\_paths_i$ = $k\_paths_i$ - {$p$} \;
		{$links$} $\leftarrow$ set of links in path $p$ \;
		\uIf {($l+1 \le maxload$ $\forall l\in$ $links$)} 
		{
			$paths_i$ = $paths_i~\cup~{p}$ \;
			Update $Load~\forall l\in~links$ \;
		} %\EndIf
		\uIf {( $k\_paths_i$ != $\phi~\forall i$ )} 
		{
			break \;
		} %\EndIf
	} %\EndWhile
% \EndFunction
~\\
% \Function {heuristic\_search}{}
	\While {($paths_i~!=~\phi~\forall i \in \mathcal{P}$)} 
	{
		call find\_paths() \; 
		$maxload ++$ \;
	} %\EndWhile
% \EndFunction
%\end{algorithmic}
\caption{Heuristic to search paths for each source-destination pair from $k$ shortest paths.}
\label{alg:heu}
\end{algorithm}
%Init:
%    \begin{algorithmic}
%        \State queue$<$struct path$>$ \textit{selected\_paths};\\
%	int[][] loads: loads of all physical links, init to 0s.\\
%    \end{algorithmic}
%Main:
%	\For {each pair of source-dest (\textit{s$_i$}, \textit{s$_i$})}
%	    \State Get the first path \textit{p} out of set \textit{k\_paths}.
%	    \State Check if adding \textit{p} make the current load over \textit{maxload}.
%	    \If {(Not over \textit{maxload})} 
%		\State remove \textit{p} from \textit{k\_paths}.
%		\State add \textit{p} into \textit{selected\_paths}.
%		\State update load[][] with links used by \textit{p}.
%	    \Else 
%		\State check if there is at the current pair has at least one path.
%		\If {(Not having any path)}
%		    \State increase the \textit{maxload} by 1
%		\Else
%		    \State remove \textit{p} from \textit{k\_paths}.
%		\EndIf
%	    \EndIf
%	\EndFor

The input to the heuristic algorithm include the set of source-destination pairs $\mathcal{P}$ = \{(S, D) $|$ S, D $\in~N$\}, their $k$ shortest paths {$k\_paths$}, the maximum allowed load on a link $maxload$ and the link load matrix $Load$. $Load$ is a table of loads on all physical links. Whenever a link $(u,v)$ is selected by the heuristic, the corresponding entry $Load[u][v]$ is increased by 1. The heuristic outputs a set of selected paths $paths$ for data movement for each source-destination pair. 

We iterate through all pairs of source/destination. For each pair of source/destination, we get the first path out of its set of \textit{k\_paths}. We check if adding the path to its \textit{selected\_paths} would make the maximum load in the \textit{load} table over \textit{maxload}. We check the load by going through all links used by the path and examine their current loads in the \textit{load} table in comparison with \textit{maxload}. If their current load adding by 1 is not over \textit{maxload} we then add the path \textit{p} into \textit{selected\_paths}, update the \textit{load} table and remove the path from \textit{k\_paths}. We iterate through all pairs and add at most one path per pair at a time. The algorithm completes when we either running out of paths to add or the maximum load of physical links in \textit{load} table is over \textit{maxload}.

In the algorithm, we also check if under the current \textit{maxload} a pair of source/destination is not able to add any paths for transferring data. If so, we increase the \textit{maxload} by 1 until we can add a path to the pair. We do so to make sure that we have at least 1 path to transfer data from its source to its destination.

In Algorithm \ref{alg:heu} we aim on balancing the number of paths using physical link. We identify number of paths on a link to actual amount of data transferred on the link.  Thus, the data movement performs well if each path carries similar amount of data. In real applications, it is not always the situation. Due to different data sizes and different number of paths, data size per path can vary. In order to gain better performance, we need a better way to determine the amount of data to be transferred on each path. In the next section, we propose another approach that employs a mathematical model and solvers to in determining  amount of data to be transferred on each path.
