\subsection{Heuristic Approach}

Given the set of k shortest paths \textit{k\_paths} for each pair of communication, we need to select paths to be used for data movement to result in high performance. In this approach, we assume that each path carries similar amount of data. Thus, the number of paths using a link can represent to the load of the link. In order to avoid overloading on physical links and achieve high performance, we select paths in such a way that satisfy 2 conditions: (1) we can employ as many paths for any pair of source/destination as possible and (2) the maximum number of paths using any physical link is less than a given \textit{maxload} value. While the first condition gives us as many as possible paths thus potentially high performance, the second condition gives us some controls over max load on physical links. Going through all combinations of paths for all pairs to examine the 2 conditions are time consuming. We propose a heuristic algorithm that can get us close to satisfying the 2 conditions while examining much less possiblity. The algorithm is presented in \textbf{Algorithm} \ref{alg:heu}. 

In the algorthm, we achieve out goal by iterating through all pairs of source/destination. For each pair of source/destination, we add a path ....

\begin{algorithm}[!htbp]
\textbf{Input:} Set of pairs of source-destination (\textit{s$_i$, d$_i$}) and their \textit{k\_paths}. \textit{maxload}\\
\textbf{Output:} Set of paths: \textit{selected\_paths} for data movement\\
Init:
    \begin{algorithmic}
        \State queue$<$struct path$>$ \textit{complete\_paths};\\
	int[][] loads: loads of all physical links, init to 0s.\\
    \end{algorithmic}
Main:
\begin{algorithmic}
    \Function {Heuristic\_search}{}
	\For {each pair of source-dest (\textit{s$_i$}, \textit{s$_i$})}
	    \State Get the first path \textit{p} out of set \textit{k\_paths}.
	    \State Check if adding \textit{p} make the current load over \textit{maxload}.
	    \State If Not, add \textit{p} into \textit{complete\_paths}
	    \State If Yes, check if there is at the current pair has at least one path.
	    \State If Not, increase the \textit{maxload} by 1
	\EndFor
    \EndFunction
\end{algorithmic}

\caption{Heuristic Algorithm based on k shortest paths}
\label{alg:heu}

\end{algorithm}

We explain the algorithm in detail below.

In the heuristic algorithm, inputs of the algorithm include pairs of sources and destination together with their k shortest paths, allowed maxload. Outputs of the approach include set of selected paths used for data movement. The algorithm is presented in \textbf{Algorithm} \ref{alg:h2}.

In Agorithm 1 and 2, we aim on balancing the number of paths using physical link. However, we do not consider the actual amount of data transferred on each path. If multiple paths are found, the data is equally split among the paths. To gain better performance, we determine the amount of data to be transferred on each path by using a mathematical model to search for the amount of data to be transferred on each path. The approach takes a number of given paths and amount of data between 2 vertices and use solvers to search for the amount of data on each path. The detail is described as follows.

\subsection{Model Optimization Approach}

How do we come up with the model?

Here is the model with its description below.

\begingroup
\fontsize{9pt}{9pt}\selectfont

\begin{verbatim}

set Nodes;
set Arcs within Nodes cross Nodes;

set Jobs;
set Paths{Jobs};
set Path_Arcs{job in Jobs, p in Paths[job]} 
    within Arcs;

param Capacity{Arcs} >= 0 default Infinity;
param Demand {Jobs} default 0;

var Flow {job in Jobs, Paths[job]} >= 0;
var Z >= 0;

maximize obj: Z;

subject to

demand {job in Jobs}: sum {p in Paths[job]} 
	Flow[job,p] = Demand[job]*Z;

capacity {(i,j) in Arcs}:
  sum {job in Jobs, p in Paths[job]: 
    (i,j) in = Path_Arcs[job,p]} Flow[job,p] 
		<= Capacity[i,j];

\end{verbatim}

\endgroup

Model explanation:
\begin{itemize}
\item sets: we have 5 sets: \textit{Nodes}, \textit{Arcs}, \textit{OD}, \textit{Paths} and \textit{Path\_Arcs}. \textit{JobID}: is the set of transfers from sources to destinations. Each job is represented by a tuple (id, source, destination, demand (total data size to transfer)).
\item params: {\it Capacity}: capacity of each arc; {\it Demand}: amount of data to be transferred in each job between a pair of orgin and destination.
\item vars: \textit{Flow}: total flow of each job on each arc; \textit{Z}: is reversed of total time; \textit{total\_flow} total flow of all jobs going through an arc.
\item objective function: we want to minimize the time or maximize its reversed value i.e. maximize \textit{Z}.
\item constraints(subject to): \textit{zero\_flow}: total flow through a source is total going out of that source, total flow going through a destination is total flow going in that destination, for other nodes that total is 0; \textit{capacity}: total flow on an arc is less than its capacity.
\end{itemize}

We feed the model to solvers and get the paths with given proportional bandwidth. Based on that, we can decide how much data we can transfer alogn each path.

\begin{comment}
So far, we have presented different algorithms/approaches. Each has its own use case scenario. The Table \ref{tbl:approaches} describes the situation when to use each of them. 

\begin{table}[h]

\begin{center}
    \begin{tabular}{ | p{0.8cm} | p{2cm} | p{2cm} | p{2cm} |}
    \hline
     & BFS-based &  \multicolumn{2}{ c| }{Path-based} \\ \hline
     & Heuristics 1 & Heuristics 2 & Optimization Model \\ \hline
    Time Complexity & $O$(K * ($|$V$|$ + $|$E$|$)) & $O$(K * (Time complexity of the algrithms used to get k shortest paths)) & $O$(K * (Time complexity of the algrithms used to get k shortest paths) + Solving time) \\ \hline
    When to use & Very dense communication & Sparse comminication &  Medium dense where proportional throughtput can be gained \\
    \hline
    \end{tabular}

    \caption{Approaches: time complexity and usage}
    \label{tbl:approaches}

\end{center}
\end{table}

\end{comment}

We realize algoirthms and other work in a framework named OPTIQ.
