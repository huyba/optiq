\documentclass[letter]{article}

\usepackage{fullpage}
\usepackage{url}

%\author{Huy Bui, Venkatram Vishwanath, Preeti Malakar, Eun-Sung Jung, Todd S. Muson, Sven Leyffer \\
%unikey: \texttt{gwil0792}
%}
\title{OPTIQ: Problem Description, Approaches and Executing Steps}
%\date{\today}

\begin{document}
\maketitle

%\begin{table}[!th]
%\begin{tabular}{l p{0.8\textwidth}}
%Supervisor & Prof. Sanjay Chawla \\
%Project Title & Scalable Computational Methods for Estimating Commute Time and Diffusion Distance on Large Graphs \\
%Desk location & 4W-26 \\
%\end{tabular}
%\end{table}

%\begin{abstract}
%\end{abstract}

%\newpage
\section{Introduction}
This is to help define the problem of data movement and optimization.

\begin{itemize}
\item Problem description: Given data movement need at application level in a cluster, minimize the total data movement time. The data movement need at the application level is stated as: process X transfers Y amount of data to process Z (for data movement between processes), or process X writes Y amount of data to storage (I/O).
\item Motivation: Data movement optimization is currently done separately at various levels (application, middleware, system routing). To improve the performance, we need to do it holistically i.e. taking all levels into consideration.
\item Inputs: 
\begin{itemize}
\item Data movement need: Each data movement request is described by a triple of (source, destination, demand), where demand is an amount of data needs to be transferred. There is a set of data movement requests for a set of sources to another set of destinations.
\item System information: system's interconnect network topology, compute/bridge/IO nodes coordination, IO nodes distribution, network routers location, bandwidth/capacity of each link in the system. 
\end{itemize}
\item Goal: To minimize the data transferring time.
\item Approach: model the system information and data movement patterns using a mathematical modeling language, optimize the data movement using solvers and execute  flows of data movement produced by the solvers. As multiple flows can begin at a node, we need to come up with a solution to share the bandwidth between the flows. One of that is time-sliced approach where each flow can occupied the transportation means in a period of time. This is similar to time division technique in optical cable.
\end{itemize}

There are 3 levels of problem solving that we are aiming to:
\begin{itemize}
\item Level 1: Current systems with no QoS support: to minimize the time to solution, with no QoS supported, we use software to provide QoS in time-sliced manner.
\item Level 2: Futuristic/current systems with hardware-supported QoS providing through software API: Given that a system may provide QoS capability at each router we can achieve the proportional bandwidth (given for each flow) by leveraging hardware-supported QoS.
\item Level 3: Dynamic changes of data movement need at runtime. Or data movement optimization in a system with capability of programmable routing through a software API. Explain this, be specific.
\end{itemize}

In each level we can also choose to add more or less constraints leading to less or more time to run. Be specific.

In this project, we are aiming to solve the problem at Level 1 and Level 2.

Note: Users do not provide QoS parameters (such as IO flow has 60\% of bandwidth). The QoS parameters such as proportional bandwidth given for each flow are produced by a solver. In order to minimize data transfer time, the solver searches for the proportional bandwidth each flow should have at each node. In a system that provides QoS capability and we leverage that capability to realize the flows generated by the solvers. In a system that does not provide QoS capability, we implement a software-based QoS in time-sliced manner.

\section {Systems to explore}
We will explore the following systems: 
\begin{itemize}
\item IBM Blue Gene Q - Mira.
\item Cray XE6 - Hopper
\item Cray XC30 - Edison
\item Others: other systems that use QoS or have different interconnection networks can be used such as Turkey or Blues. These two systems use InfiniBand interconnection network providing hardware supported QoS features.
\end{itemize}

\section{Project steps}

The project includes the main following steps:
\begin{itemize}
\item Using a modeling language to model system's configuration, data movement request (optiq.mod).
\item Generating data for specific systems: interconnection network as a graph and modeling the data movement on it (optiq.dat).
\item Optimizing data movement need using existing solvers.
\item Time slice data movement implementation.
\item Microbenmark and Calibration.
\item Experiment on data movement patterns from applications.
\end{itemize}

\subsection {AMPL model to capture system information and applications' data movement patterns}

We choose to model the problem as network flow optimization. There are 2 instances of network flow optimization that we consider for our problem modeling.

\begin{itemize}
\item Single commodity: There are n sources that need to send a commodity/data to m nodes. However, the commodity is treated in the same way i.e it doesn't matter which destination a data will be sent to from a source. This can be used for I/O data. As all the data received will be treated in the same way i.e. write to disk.
\item Multiple commodity: When compute nodes exchange data, the data from a source node must go to a specific destination node. Data on s pair of (source, destination) is considered as a commodity. As we have multiple pairs of sources and destinations, we have multiple commodity flows. In general, each pair of source, destination that have data on it can be considered as a commodity.
\end{itemize}

In our problem, we may have both I/O and communication between compute nodes happen at the same time. While we consider each data movement between 2 compute nodes as a commodity. All I/O data is considered as single commodity. We do so by adding one super-node, connecting to all I/O nodes. All I/O data will destine to the super-node.

In this step, we create a model in AMPL to capture general system's interconnection network characteristics and data movement patterns.

\begin{itemize}
\item Input: An abstract description of system's interconnection network and data movement patterns.
\item Output: A model.
\begin{itemize}
\item set Nodes: set of nodes.
\item set Arcs: set of arcs = Node cross Node.
\item parameter Capacity: the bandwidth on each link. No path is 
\item parameter Delay: delay at each node for message processing, injecting and receiving.
\item parameter NumHops: number of hops between a node and its neighbor.
\item objective function: minimize the time to move all of the data.
\item constraint zero\_flow: 
\item constraint longest\_hops: the maximum number of hops that a path can have. Any path that is longer than this will be discarded. I think that solvers will still look for paths with longer number of hops, after they're done searching, they simply use this constrant to discard the path. The solvers do not use this to limit the number of paths to be searched.
\item constraint max\_capacity: sum of all flows on a link does not surpass its capacity.
\item parameter Source of a job.
\item parameter Destination of a job.
\item parameter Demand of a job: a commodity that need to transfer from a Source to a Destination.
\end{itemize}
\end{itemize}

\subsection {Creating graphs representing interconnection networks}
\begin{itemize}
\item Input: network topology, coordinates of nodes that host processes, links between nodes and capacities on links.
\item Output: a graph representation of communication on a system.
\end{itemize}

\subsubsection{Techniques for large interconnection networks modeling}
\begin{itemize}
\item Do not include the part of the graph that we do not expect them to be involve into communication: if the number hops on a path exceed a predetermined number, we can discard that path. Or if the communication happens within a rack, we do not have to take other racks into consideration.
\item Graph partitioning technique: We partition a graph into subgraphs hierarchically.
\end{itemize}

\subsubsection{k-D (torus) interconnection networks}
There are 3D, 5D or 6D (torus) interconnection network. In these interconnection networks, a compute node connects to its 6/10/12 (2k) neighbors. %This type of interconnection network does not scale well when the number of compute nodes increases the number of hops and links increase faster.

We can divided the interconnection network into set of (k-i)D paritions with i = 0..k.

\subsubsection{Hierarchical interconnection networks}
There are tree-like interconnection network such as Fat Tree interconnection network or Dragonfly interconnection network. 

We can divide a parition of nodes into set of subgraphs based on the hierrachical structure of the network.

How do we model the node and link capacity on each. Given 2 set of nodes: set of source nodes in partition p1

Given 2 partition P1 and P2, with P1 has m node, and p2 has n nodes with l links of capacity C each between them. A set of k source nodes in P1 need to communicate with another set of l destination nodes on P2. We wil model all nodes in set P1 as a node, and all destination nodes in P2 as another node. The bandwidth between these link is (k+l)/(m+n)*l*C

Each rack/group can be considered as a node. If exist a direct connection between 2 group, we create an arc that connect the 2 nodes preseting the 2 groups. The capacity of that arc is proportional bandwidth the the link. We compute the capacity of that arc based on the number of nodes given for each group.

\subsubsection{Example of IBM Blue Gene/Q Mira' custom 5D interconnect network}

\subsubsection{Example of Cray XC30 Edison's Dragonfly interconnect network}

Each Aries is a node in the graph. At a node, there are 4 processors sharing that Aries. So every process/MPI\_Rank that have data transfer requests can be mapped to that same node. Each Aries has 48 routing tiles: 15 of them can be used to connect to 15 Aries in the same Chassis.

\subsection{Creating application data movement patterns on a graph}
We need to map between data movement requests of applications into the graph that we have generated above. As each 
Distinguishing between rank, node, blade, network router.

\subsection {Optimization tools}
Two optimization set of tools can be used here:
\begin{itemize}
\item Proprietary software tools: IBM solvers. Can not be used directly on supercomputer nodes, have to you run from MCS machines.
\item Open source tools: free tools such as lpp. Also can be used directly on the supercomputers.
\end{itemize}

Input, output of this step:
\begin{itemize}
\item Input: the model and data.
\item Output: The minimal time to transfer data and the proportional bandwidth given for each job to achieve that minimal transfer time.
\end{itemize}

If the bandwidth allocation is generated in a file, we need to read that information from a file. If our framework generates it directly, we can use it directly. Eventually, every rank in the system has the information of the proportional bandwidth that it has for transferring data.

\subsection{Time slice data movement implementation}
\begin{itemize}
\item Input: The proportional bandwidth of each job at each node.
\item Output: All ranks that share a resource must share time. Each would get a period of time (window) that is proportional to their bandwidth proportional and transfer data within its given window.
\end{itemize}

We will need a communication thread per node/processor to do manage a global scheduling.

Implementation idea: based on the hardware supported QoS concepts/implementation on Infiniband. We have 3 main classes: Service Level, Virtual Lane, and 

\subsection{Microbenmark and Calibration}

We need to do microbenchmarks to see if our assumptions we made are valid or not. If not, then we need to calibrate them.

\subsection{Experiment on data movement patterns from applications}
\subsubsection{Communcation data movement patterns from CESM}
\subsubsection{Sparse IO pattern from HACC}
\subsubsection{Our fantasy data movement with concurrent I/O and communication}

\subsubsection{Experimental results and Evaluation}

\section{API design and use cases}
\subsection{API design}
The API design needs to take the following into consideration:

\begin{itemize}
	\item Various systems can use this with system specific implementation, with different data movement libraries: MPI, TCP/IP, PAMI, uGNI, PGAS(UPC, Charm++). Thus, we need to provide an generic API with specific implementation on each system. So that a client that uses API does not need to be aware of system that it is running on.
	\item System configuration can be read from files (either online or offline) or can be queried at runtime.
	\item The optimization can be done offline or online.
	\item The flows produced by an solver can be written to a file or can be stored in memory.
\end{itemize}

All of API's functions and data structures need to start with optiq\_. If the functions/data structures are machine specific, then they need to end with \_machine\_code such as \_bgq, \_xc30, \_xe6. Also system-specific code needs to be in separate files to make the maintenance easy. For example of querying topology we have one file for BGQ, one file for XC30, one file for XE6. They can be called through a generic interface. We use Bridge design pattern for this.

List of API functions:

Initialization;
optiq\_init(int *argc, char **argv, int optiq\_mode)

in which optiq\_mode can be OPTIQ\_OFFLINE or OPTIQ\_ONLINE

System's information collection:

Graph's construction:

Application's data movement patterns collection:

Solving and collecting flows

Data movement execution:


\subsection{Use cases/Examples of the API usage}

Steps: collecting system information, data movement patterns, optimizing, reading flows, executing flow. While reading/executing the flows needs to be done at the runtime, all other steps can be done offline.

\subsubsection{Online optimization/execution} with data patterns are input at the runtime. The patterns are known in advance: sources, destinations and data size. The applications compute on data while our framework optimizes data movement.



\subsubsection{Offline optimization, online flow execution}

\subsubsection{Hybrid mode}

\end{document}
