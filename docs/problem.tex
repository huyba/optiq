\documentclass[letter]{article}

\usepackage{fullpage}
\usepackage{url}

%\author{Huy Bui, Venkatram Vishwanath, Preeti Malakar, Eun-Sung Jung, Todd S. Muson, Sven Leyffer \\
%unikey: \texttt{gwil0792}
%}
\title{OPTIQ: Problem Description, Approaches and Executing Steps}
%\date{\today}

\begin{document}
\maketitle

%\begin{table}[!th]
%\begin{tabular}{l p{0.8\textwidth}}
%Supervisor & Prof. Sanjay Chawla \\
%Project Title & Scalable Computational Methods for Estimating Commute Time and Diffusion Distance on Large Graphs \\
%Desk location & 4W-26 \\
%\end{tabular}
%\end{table}

%\begin{abstract}
%\end{abstract}

%\newpage
\section{Introduction}
This is to help define the problem of data movement and optimization.

\begin{itemize}
\item Problem description: Given data movement need at application level in a cluster, minimize the total data movement time. The data movement need at the application level is stated as: process X transfers Y amount of data to process Z (for data movement between processes), or process X writes Y amount of data to storage (I/O).
\item Motivation: Data movement optimization is currently done separately at various levels (application, middleware, system routing). To improve the performance, we need to do it holistically i.e. taking all levels into consideration.
\item Inputs: 
\begin{itemize}
\item Data movement need: Each data movement request is described by a triple of (source, destination, demand), where demand is an amount of data needs to be transferred. There is a set of data movement requests for a set of sources to another set of destinations.
\item System information: system's interconnect network topology, compute/bridge/IO nodes coordination, IO nodes distribution, network routers location, bandwidth/capacity of each link in the system. 
\end{itemize}
\item Goal: To minimize the data transferring time.
\item Approach: model the system information and data movement patterns using a mathematical modeling language, optimize the data movement using solvers and execute  flows of data movement produced by the solvers. As multiple flows can begin at a node, we need to come up with a solution to share the bandwidth between the flows. One of that is time-sliced approach where each flow can occupied the transportation means in a period of time. This is similar to time division technique in optical cable.
\end{itemize}

There are 3 levels of problem solving that we are aiming to:
\begin{itemize}
\item Level 1: Current systems with no QoS support: to minimize the time to solution, with no QoS supported, we use software to provide QoS in time-sliced manner.
\item Level 2: Futuristic/current systems with hardware-supported QoS providing through software API: Given that a system may provide QoS capability at each router we can achieve the proportional bandwidth (given for each flow) by leveraging hardware-supported QoS.
\item Level 3: Dynamic changes of data movement need at runtime. Or data movement optimization in a system with capability of programmable routing through a software API. Explain this, be specific.
\end{itemize}

In each level we can also choose to add more or less constraints leading to less or more time to run. Be specific.

In this project, we are aiming to solve the problem at Level 1 and Level 2.

\section {Systems to explore}
We will explore the following systems: 
\begin{itemize}
\item IBM Blue Gene Q - Mira.
\item Cray XE6 - Hopper
\item Cray XC30 - Edison
\item Others: other systems that use QoS or have different interconnection networks can be used such as Turkey or Blues. Those two system use InfiniBand interconnection network providing hardware supported QoS features.
\end{itemize}

\section{Project steps}

The project includes the main following steps:
\begin{itemize}
\item Using a modeling language to capture system's configuration, data movement need.
\item Modeling system's interconnection network as a graph and modeling the data movement on it.
\item Optimizing data movement need using existing solvers.
\item Time slice data movement implementation.
\item Microbenmark and Calibration.
\item Experiment on data movement patterns from applications.
\end{itemize}

Note: Users do not provide QoS as parameters (such as IO have 60\% of bandwidth). A solver in minimizing the data transfer time will search for the proportional bandwidth each flow will have at each node. In a system that provides QoS capability and we leverage that feature to realize the flows generated by the solvers. In a system that does not provide QoS capability, we implement a software-based QoS using time-sliced manner.

\subsection {AMPL model to capture system information and applications' data movement patterns}
In this step, we need to create a model to capture the system's interconnection network characteristics and data movement patterns.

We choose to model the problem as the single and multiple commodity flow.

Single commodity: There are n sources that need to send a commodity/data to m nodes, but the commodity is the same or data is treat in the same way/considered no difference which ever destination nodes receive the data. This can be used for I/O data. As all the data receive will be treated in the same way i.e. write to disk. 

However, with data that is communicated between compute nodes for the computational purposes, the need to be treated differently. There comes the multiple commodity flows. In general, each pair of source, destination that have data on it can be considered as a commodity. If it is one-to-all, then we can considered it a single commodity. So the problem of I/O is the single commodity flow problem and the problem of communication is likely the multiple commodity flow problem.

\begin{itemize}
\item AMPL model to capture system information, data movement need
Single commodity flow. In this model, we assume that all the messages are the same type. They will be treated equally.
\begin{itemize}
\item Input:
\begin{itemize}
\item set Nodes: set of nodes.
\item set Arcs: set of arcs = Node cross Node.
\item parameter Capacity: the bandwidth on each link. No path is 
\item parameter Delay: delay at each node for message processing, injecting and receiving.
\item parameter NumHops: number of hops between a node and its neighbor.
\item objective function: minimize the time to move all of the data.
\item constraint zero\_flow: 
\item constraint longest\_hops: the maximum number of hops that a path can have. Any path that is longer than this will be discarded. I think that solvers will still look for paths with longer number of hops, after they're done searching, they simply use this constrant to discard the path. The solvers do not use this to limit the number of paths to be searched.
\item constraint max\_capacity: sum of all flows on a link does not surpass its capacity.
\end{itemize}
\item Output: the bandwith amount given for each job. The bandwidth is given for each job at the node that the job passes by. 
\end{itemize}

\item AMPL model to capture system information, data movement need and QoS 
Multiple commodity flow: In this model, we assume that there are various types of flows. Each types can be given a portion of the bandwidth of a link to transfer data. So the bandwidth here can be given different at each link? or we give them the same bandwidth porporition? If we allow different porportion, we likely have smaller data transferring time than if we do not allow.

The question here is: is this different from the previous one? We still model it, solve the model and get a proportional bandwidth for each flow.

Assume that we have 2 different flows but treat them as they are the same. 

The optimization objective is still to minimize the data transferring time.

For the current system, we aim to try with 2 classes of flow: IO and QoS.
\begin{itemize}
\item Input:
\begin{itemize}
\item set Types: set of types such as IO and COMM.
\item var weight: weigh given for each job at each link.
\end{itemize}

\end{itemize}
\end{itemize}

\subsection {Interconnection networks modeling}
\begin{itemize}
\item Input:
\item Output:
\end{itemize}

\subsubsection{Techniques for large interconnection networks modeling}
\begin{itemize}
\item Do not include the part of the graph that we do not expect them to be involve into communicatio: if the communication happend between nodes within a rack/group we do not involve nodes that outside of that rack/group to reduce the size problem.
\item Graph partitioning technique: We partition a graph into subgraphs hierrachically.
\end{itemize}

\subsubsection{k-D interconnection networks}
There are 3D, 5D or even 6D interconnection network. In these interconnection networks, a compute node connects to its 6/10/12 (2k) neighbors. %This type of interconnection network does not scale well when the number of compute nodes increases the number of hops and links increase faster.

We can divided the interconnection network into set of (k-i)D paritions with i = 0..k.

\subsubsection{Hierarchical interconnection networks}
There are for tree-like interconnection network such as Fat Tree interconnection network or Dragonfly interconnection network. 

We can divide a parition of nodes into set of subgraphs based on the hierrachical structure of the network.

How do we model the node and link capacity on each. Given 2 set of nodes: set of source nodes in partition p1

Given 2 partition P1 and P2, with P1 has m node, and p2 has n nodes with l links of capacity C each between them. A set of k source nodes in P1 need to communicate with another set of l destination nodes on P2. We wil model all nodes in set P1 as a node, and all destination nodes in P2 as another node. The bandwidth between these link is (k+l)/(m+n)*l*C

Each rack/group can be considered as a node. If exist a direct connection between 2 group, we create an arc that connect the 2 nodes preseting the 2 groups. The capacity of that arc is proportional bandwidth the the link. We compute the capacity of that arc based on the number of nodes given for each group.

\subsection{Data movement optimization}
We need to map between data movement requests of applications into the graph that we have generated above. As each 
Distinguishing between rank, node, blade, network router.

\subsubsection{Example of IBM Blue Gene/Q Mira' custom 5D interconnect network}

\subsubsection{Example of Cray XC30 Edison's Dragonfly interconnect network}

Each Aries is a node in the graph. At a node, there are 4 processors sharing that Aries. So every process/MPI\_Rank that have data transfer requests can be mapped to that same node. Each Aries has 48 routing tiles: 15 of them can be used to connect to 15 Aries in the same Chassis. 

\subsection {Optimizing data movement need}
Two optimization set of tools can be used here:
\begin{itemize}
\item Proprietary software tools: IBM solvers. Can not be used directly on supercomputer nodes, have to you run from MCS machines.
\item Open source tools: free tools such as lpp. Also can be used directly on the supercomputers.
\end{itemize}

Input, output of this step:
\begin{itemize}
\item Output:
\item The
\end{itemize}

If the bandwidth allocation is generated in a file, we need to read that information from a file. If our framework generates it directly, we can use it directly. Eventually, every rank in the system has the information of the proportional bandwidth that it has for transferring data.

\subsection{Time slice data movement implementation}
\begin{itemize}
\item Input: The proportional bandwidth of each job at each node.
\item Output: All ranks that share a resource must share time. Each would get a period of time that is proportional to their bandwidth proportional.
\end{itemize}

Implementation idea: based on the hardware supported QoS concepts/implementation on Infiniband. We have 3 main classes: Service Level, Virtual Lane, and 

\subsection{Microbenmark and Calibration}

We need to do microbenchmarks to see if our assumptions we made are valid or not. If not, then we need to calibrate them.

\subsection{Experiment on data movement patterns from applications}
\subsubsection{Communcation data movement patterns from CESM}
\subsubsection{Sparse IO pattern from HACC}
\subsubsection{Our fantasy data movement with concurrent I/O and communication}

\subsubsection{Experimental results and Evaluation}

\section{API design and use cases}
\subsection{API design}
The API design needs to take the following into consideration:

\begin{itemize}
	\item Various systems can use this with system specific implementation, with different data movement libraries: MPI, TCP/IP, PAMI, uGNI, PGAS(UPC, Charm++). Thus, we need to provide an generic API with specific implementation on each system. So that a client that uses API does not need to be aware of system that it is running on.
	\item System configuration can be read from files (either online or offline) or can be queried at runtime.
	\item The optimization can be done offline or online.
	\item The flows produced by an solver can be written to a file or can be stored in memory.
\end{itemize}

All of API's functions and data structures need to start with optiq\_. If the functions/data structures are machine specific, then they need to end with \_machine\_code such as \_bgq, \_xc30, \_xe6. Also system-specific code needs to be in separate files to make the maintenance easy. For example of querying topology we have one file for BGQ, one file for XC30, one file for XE6. They can be called through a generic interface. We use Bridge design pattern for this.

List of API functions:

Initialization;
optiq\_init(int *argc, char **argv, int optiq\_mode)

in which optiq\_mode can be OPTIQ\_OFFLINE or OPTIQ\_ONLINE

System's information collection:

Graph's construction:

Application's data movement patterns collection:

Solving and collecting flows

Data movement execution:


\subsection{Use cases/Examples of the API usage}

Steps: collecting system information, data movement patterns, optimizing, reading flows, executing flow. While reading/executing the flows needs to be done at the runtime, all other steps can be done offline.

\subsubsection{Online optimization/execution} with data patterns are input at the runtime. The patterns are known in advance: sources, destinations and data size. The applications compute on data while our framework optimizes data movement.



\subsubsection{Offline optimization, online flow execution}

\subsubsection{Hybrid mode}

\end{document}
